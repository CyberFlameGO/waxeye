{"version":3,"sources":["webpack://waxeye/webpack/universalModuleDefinition","webpack://waxeye/webpack/bootstrap","webpack://waxeye/./cons_list.ts","webpack://waxeye/./expr.ts","webpack://waxeye/./waxeye.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","cons","head","tail","Cons","empty","Empty","instance","result","this","currentTail","isEmpty","push","iterator","current","done","next","exprToRuntimeExpr","expr","type","exprs","reduceRight","WaxeyeParser","config","start","env","nonterminal","entries","exp","parserConfigToRuntimeParserConfig","input","Error","keys","join","action","moveEval","evalNext","RawError","continuations","moveReturn","moveApply","match","AST","children","end","length","EmptyAST","ErrChar","char","JSON","stringify","slice","ErrCC","charClasses","map","charClass","String","fromCodePoint","ErrAny","ParseError","pos","line","col","nt","chars","err","toGrammarString","nonterminals","failedChars","currentNT","lineNumber","lineStartPos","newlinePos","indexOf","getLineCol","uniqueNonterminals","seenNonterminals","Set","has","add","toArray","reverse","updateError","e","contSeq","expressions","contAlt","asts","contStar","expression","accept","reject","applyNext","eof","isSingleCharCodepoint","codePointAtOrFail","contAnd","contNot","contVoid","cc","codepoints","inputCodePoint","contOpt","startPos","contNT","evaluated","rest","accepted","valAsts","newErr","checkExhaustive","moveApplyOnAccept","rejected","moveApplyOnReject","toParseError","ast","codePoint","codePointAt","message"],"mappings":"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","file":"waxeye.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"waxeye\"] = factory();\n\telse\n\t\troot[\"waxeye\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// A type-safe immutable homogenous \"persistent\" cons list.\n// A cons list is either empty or a cons pair of T and a cons list.\nexport type ConsList<T> = Cons<T>|Empty;\n\n// Creates a non-empty cons list.\nexport function cons<T>(head: T, tail: ConsList<T>): Cons<T> {\n  return new Cons<T>(head, tail);\n}\n\n// Returns the empty cons list.\nexport function empty(): Empty {\n  return Empty.instance;\n}\n\n// Methods implemented by both Empty and Cons<T>.\nexport interface ConsListInterface<T> extends Iterable<T> {\n  // Check whether the list is an Empty.\n  //\n  // Using this method is preferable to the expensive and less readable\n  // `instanceof Empty` check.\n  isEmpty(): this is Empty;\n\n  // Equivalent to [...list] but slightly faster.\n  toArray(): T[];\n}\n\n// A non-empty cons list.\nexport class Cons<T> implements ConsListInterface<T> {\n  // Internal, not public.\n  // TODO(glebm): Add the internal modifier once it's implemented in TypeScript\n  // https://github.com/Microsoft/TypeScript/issues/5228\n  constructor(public readonly head: T, public readonly tail: ConsList<T>) {}\n\n  public isEmpty(): this is Empty {\n    return false;\n  }\n\n  public toArray(): T[] {\n    const result: T[] = [this.head];\n    let currentTail = this.tail;\n    while (!currentTail.isEmpty()) {\n      result.push(currentTail.head);\n      currentTail = currentTail.tail;\n    }\n    return result;\n  }\n\n  public[Symbol.iterator](): Iterator<T> {\n    let current: ConsList<T> = this;\n    return {\n      next(): IteratorResult<T> {\n        if (current.isEmpty()) {\n          // This typecast is necessary because TypeScript incorrectly\n          // specifies both `done` and `value` as required.\n          return {done: true} as IteratorResult<T>;\n        }\n        const value = current.head;\n        current = current.tail;\n        return {value} as IteratorResult<T>;\n      },\n    };\n  }\n}\n\n// An empty cons list.\nexport class Empty implements ConsListInterface<never> {\n  public static readonly instance = new Empty();\n  private constructor() {}\n  public isEmpty(): this is Empty {\n    return true;\n  }\n  public toArray(): [] {\n    return [];\n  }\n  public[Symbol.iterator](): Iterator<never> {\n    return {\n      next(): IteratorResult<never> {\n        return {done: true} as IteratorResult<never>;\n      },\n    };\n  }\n}\n","// We have two representations for expression:\n// the config one, and the internal one.\n\n// The config representation is JSON-compatible.\n// The internal one is optimized for performance.\n\nimport {cons, ConsList, empty} from './cons_list';\n\nexport function exprToRuntimeExpr(expr: Expr): RuntimeExpr {\n  switch (expr.type) {\n    case ExprType.NT:\n    case ExprType.CHAR:\n    case ExprType.CHAR_CLASS:\n    case ExprType.ANY_CHAR:\n      return expr;\n    case ExprType.PLUS:\n    case ExprType.STAR:\n    case ExprType.OPT:\n    case ExprType.AND:\n    case ExprType.NOT:\n    case ExprType.VOID:\n      return {type: expr.type, expr: exprToRuntimeExpr(expr.expr)} as\n          RuntimeExpr;\n    case ExprType.ALT:\n    case ExprType.SEQ:\n      return {\n        type: expr.type,\n        exprs: expr.exprs.reduceRight(\n            (result: ConsList<RuntimeExpr>, value: Expr):\n                ConsList<RuntimeExpr> => cons(exprToRuntimeExpr(value), result),\n            empty()),\n      } as RuntimeExpr;\n  }\n}\n\nexport type Expr = NonRecursiveExpr|ExprPlus|ExprStar|ExprOpt|ExprAnd|ExprNot|\n    ExprVoid|ExprAlt|ExprSeq;\nexport type RuntimeExpr =\n    NonRecursiveExpr|RuntimeExprPlus|RuntimeExprStar|RuntimeExprOpt|\n    RuntimeExprAnd|RuntimeExprNot|RuntimeExprVoid|RuntimeExprAlt|RuntimeExprSeq;\nexport type NonRecursiveExpr =\n    ExprNonTerminal|ExprChar|ExprCharClass|ExprAnyChar;\n\nexport const enum ExprType {\n  NT = 1,\n  ALT,\n  SEQ,\n  PLUS,\n  STAR,\n  OPT,\n  AND,\n  NOT,\n  VOID,\n  ANY_CHAR,\n  CHAR,\n  CHAR_CLASS,\n}\n\nexport interface ExprNonTerminal {\n  type: ExprType.NT;\n  name: string;\n}\n\nexport interface ExprAnyChar {\n  type: ExprType.ANY_CHAR;\n}\n\nexport interface ExprChar {\n  type: ExprType.CHAR;\n  // A single character (represented by a single Unicode codepoint).\n  char: string;\n}\n\nexport interface ExprCharClass {\n  type: ExprType.CHAR_CLASS;\n  // A list of Unicode codepoints / ranges of codepoints.\n  codepoints: Array<number|[number, number]>;\n}\n\nexport interface ExprAlt {\n  type: ExprType.ALT;\n  exprs: Expr[];\n}\nexport interface RuntimeExprAlt {\n  type: ExprType.ALT;\n  exprs: ConsList<RuntimeExpr>;\n}\n\nexport interface ExprSeq {\n  type: ExprType.SEQ;\n  exprs: Expr[];\n}\nexport interface RuntimeExprSeq {\n  type: ExprType.SEQ;\n  exprs: ConsList<RuntimeExpr>;\n}\n\nexport interface ExprPlus {\n  type: ExprType.PLUS;\n  expr: Expr;\n}\nexport interface RuntimeExprPlus {\n  type: ExprType.PLUS;\n  expr: RuntimeExpr;\n}\n\nexport interface ExprStar {\n  type: ExprType.STAR;\n  expr: Expr;\n}\nexport interface RuntimeExprStar {\n  type: ExprType.STAR;\n  expr: RuntimeExpr;\n}\n\nexport interface ExprOpt {\n  type: ExprType.OPT;\n  expr: Expr;\n}\nexport interface RuntimeExprOpt {\n  type: ExprType.OPT;\n  expr: RuntimeExpr;\n}\n\nexport interface ExprAnd {\n  type: ExprType.AND;\n  expr: Expr;\n}\nexport interface RuntimeExprAnd {\n  type: ExprType.AND;\n  expr: RuntimeExpr;\n}\n\nexport interface ExprNot {\n  type: ExprType.NOT;\n  expr: Expr;\n}\nexport interface RuntimeExprNot {\n  type: ExprType.NOT;\n  expr: RuntimeExpr;\n}\n\nexport interface ExprVoid {\n  type: ExprType.VOID;\n  expr: Expr;\n}\nexport interface RuntimeExprVoid {\n  type: ExprType.VOID;\n  expr: RuntimeExpr;\n}\n","/*\n * Waxeye Parser Generator http://www.waxeye.org\n * Licensed under the MIT license. See 'LICENSE' for details.\n */\n\nimport {cons, ConsList, empty} from './cons_list';\nimport {Expr, exprToRuntimeExpr, ExprType, RuntimeExpr} from './expr';\n\nexport {Expr, ExprType} from './expr';\n\nexport class WaxeyeParser {\n  private readonly env: RuntimeParserConfig;\n  public constructor(\n      public readonly config: ParserConfig,\n      public readonly start: string /* keyof env */) {\n    this.env = parserConfigToRuntimeParserConfig(config);\n  }\n\n  public parse(input: string, start: string = this.start): AST|ParseError {\n    if (!this.env[start]) {\n      throw new Error(`Invalid non-terminal ${start}. Expected one of: ${\n          Object.keys(this.env).join(', ')}`);\n    }\n    return match(this.env, start, input);\n  }\n}\n\nexport interface ParserConfig {\n  // name -> ParserConfigNonTerminal\n  [key: string]: {mode: NonTerminalMode, exp: Expr};\n}\ninterface RuntimeParserConfig {\n  // name -> ParserConfigNonTerminal\n  [key: string]: {mode: NonTerminalMode, exp: RuntimeExpr};\n}\n\nfunction parserConfigToRuntimeParserConfig(config: ParserConfig):\n    RuntimeParserConfig {\n  const result: RuntimeParserConfig = {};\n  for (const [name, nonterminal] of Object.entries(config)) {\n    result[name] = {\n      mode: nonterminal.mode,\n      exp: exprToRuntimeExpr(nonterminal.exp),\n    };\n  }\n  return result;\n}\n\nexport const enum NonTerminalMode {\n  NORMAL = 1,\n  PRUNING,\n  VOIDING,\n}\n\n/*\n * An abstract syntax tree holds the non-terminal's name (`type`),\n * and a list of child ASTs.\n */\nexport class AST {\n  constructor(\n      public type: string, public children: Array<AST|string>,\n      public start: number, public end: number) {}\n\n  /**\n   * The empty AST is an AST that has an empty `type` and no children.\n   */\n  public isEmpty(): this is EmptyAST {\n    return this.type === '' && this.children.length === 0;\n  }\n}\n\nexport interface EmptyAST extends AST {\n  type: '';\n  children: never[];\n}\n\nexport function EmptyAST(start: number, end: number): EmptyAST {\n  return new AST('', [], start, end) as EmptyAST;\n}\n\nexport interface MatchError {\n  // Expected expression in the grammar format.\n  toGrammarString(): string;\n}\n\n// A failed single character match.\nexport class ErrChar implements MatchError {\n  constructor(public char: string) {}\n\n  public toGrammarString() {\n    return `'${JSON.stringify(this.char).slice(1, -1)}'`;\n  }\n}\n\n// A failed character class match.\nexport class ErrCC implements MatchError {\n  // A list of Unicode codepoints / ranges of codepoints.\n  constructor(public charClasses: Array<number|[number, number]>) {}\n\n  public toGrammarString() {\n    return `[${\n        this.charClasses\n            .map((charClass) => {\n              return JSON\n                  .stringify(\n                      typeof charClass === 'number' ?\n                          String.fromCodePoint(charClass) :\n                          `${String.fromCodePoint(charClass[0])}-${\n                              String.fromCodePoint(charClass[1])}`)\n                  .slice(1, -1);\n            })\n            .join('')}]`;\n  }\n}\n\n// A failed wildcard match.\nexport class ErrAny implements MatchError {\n  public toGrammarString() {\n    return '.';\n  }\n}\n\nexport class ParseError {\n  constructor(\n      public pos: number, public line: number, public col: number,\n      public nt: string[], public chars: MatchError[]) {}\n\n  public toString(): string {\n    const chars =\n        this.chars.map((err) => err.toGrammarString()).join(' | ') || '\\'\\'';\n    return `Parse error: Failed to match '${this.nt.join(',')}' at line=${\n        this.line}, col=${this.col}, pos=${this.pos}. Expected: ${chars}`;\n  }\n}\nclass RawError {\n  constructor(\n      public pos: number, public nonterminals: ConsList<string>,\n      public failedChars: ConsList<MatchError>, public currentNT: string) {}\n\n  public toParseError(input: string): ParseError {\n    const [line, col] = getLineCol(this.pos, input);\n    const uniqueNonterminals: string[] = [];\n    const seenNonterminals = new Set<string>();\n    for (const nt of this.nonterminals) {\n      if (seenNonterminals.has(nt)) {\n        continue;\n      }\n      uniqueNonterminals.push(nt);\n      seenNonterminals.add(nt);\n    }\n    return new ParseError(\n        this.pos, line, col, uniqueNonterminals,\n        this.failedChars.toArray().reverse());\n  }\n}\n\nfunction updateError(err: RawError, pos: number, e: MatchError): RawError {\n  if (err !== null) {\n    if (pos > err.pos) {\n      return new RawError(\n          pos, cons(err.currentNT, empty()), cons(e, empty()), err.currentNT);\n    } else if (pos === err.pos) {\n      return new RawError(\n          err.pos, cons(err.currentNT, err.nonterminals),\n          cons(e, err.failedChars), err.currentNT);\n    } else {\n      return new RawError(\n          err.pos, err.nonterminals, err.failedChars, err.currentNT);\n    }\n  } else {\n    return new RawError(0, cons('', empty()), cons(e, empty()), '');\n  }\n}\n\ntype ASTList = ConsList<AST|string>;\n\ntype Continuation =\n    ContSeq|ContAlt|ContAnd|ContNot|ContOpt|ContStar|ContPlus|ContVoid|ContNT;\n\nconst enum ContType {\n  SEQ = 1,\n  ALT,\n  AND,\n  NOT,\n  OPT,\n  STAR,\n  PLUS,\n  VOID,\n  NT,\n}\n\ninterface ContSeq {\n  type: ContType.SEQ;\n  expressions: ConsList<RuntimeExpr>;\n}\nfunction contSeq(expressions: ConsList<RuntimeExpr>): ContSeq {\n  return {type: ContType.SEQ, expressions};\n}\n\ninterface ContAlt {\n  type: ContType.ALT;\n  expressions: ConsList<RuntimeExpr>;\n  pos: number;\n  asts: ASTList;\n}\nfunction contAlt(\n    expressions: ConsList<RuntimeExpr>, pos: number, asts: ASTList): ContAlt {\n  return {type: ContType.ALT, expressions, pos, asts};\n}\n\ninterface ContAnd {\n  type: ContType.AND;\n  pos: number;\n  asts: ASTList;\n  err: RawError;\n}\nfunction contAnd(pos: number, asts: ASTList, err: RawError): ContAnd {\n  return {type: ContType.AND, pos, asts, err};\n}\n\ninterface ContNot {\n  type: ContType.NOT;\n  pos: number;\n  asts: ASTList;\n  err: RawError;\n}\nfunction contNot(pos: number, asts: ASTList, err: RawError): ContNot {\n  return {type: ContType.NOT, pos, asts, err};\n}\n\ninterface ContOpt {\n  type: ContType.OPT;\n  pos: number;\n  asts: ASTList;\n}\nfunction contOpt(pos: number, asts: ASTList): ContOpt {\n  return {type: ContType.OPT, pos, asts};\n}\n\ninterface ContStar {\n  type: ContType.STAR;\n  expression: RuntimeExpr;\n  pos: number;\n  asts: ASTList;\n}\nfunction contStar(\n    expression: RuntimeExpr, pos: number, asts: ASTList): ContStar {\n  return {type: ContType.STAR, expression, pos, asts};\n}\n\ninterface ContPlus {\n  type: ContType.PLUS;\n  expression: RuntimeExpr;\n}\nfunction contPlus(expression: RuntimeExpr): ContPlus {\n  return {type: ContType.PLUS, expression};\n}\n\ninterface ContVoid {\n  type: ContType.VOID;\n  asts: ASTList;\n}\nfunction contVoid(asts: ASTList): ContVoid {\n  return {type: ContType.VOID, asts};\n}\n\ninterface ContNT {\n  type: ContType.NT;\n  mode: NonTerminalMode;\n  name: string;\n  asts: ASTList;\n  nt: string;\n  startPos: number;\n}\nfunction contNT(\n    mode: NonTerminalMode, name: string, asts: ASTList, nt: string,\n    startPos: number): ContNT {\n  return {type: ContType.NT, mode, name, asts, nt, startPos};\n}\n\ntype MatchResult = Accepted|Rejected;\n\nconst enum MatchResultType {\n  ACCEPT = 1,\n  REJECT,\n}\n\ninterface Accepted {\n  type: MatchResultType.ACCEPT;\n  pos: number;\n  asts: ASTList;\n  err: RawError;\n}\n\nfunction accept(pos: number, asts: ASTList, err: RawError): Accepted {\n  return {type: MatchResultType.ACCEPT, pos, asts, err};\n}\n\ninterface Rejected {\n  type: MatchResultType.REJECT;\n  err: RawError;\n}\n\nfunction reject(err: RawError): Rejected {\n  return {type: MatchResultType.REJECT, err};\n}\n\nconst enum ActionType {\n  EVAL = 1,\n  APPLY,\n}\n\ninterface ActionEval {\n  type: ActionType.EVAL;\n  exp: RuntimeExpr;\n  pos: number;\n  asts: ASTList;\n  err: RawError;\n  continuations: ConsList<Continuation>;\n}\n\nfunction evalNext(\n    exp: RuntimeExpr, pos: number, asts: ASTList, err: RawError,\n    continuations: ConsList<Continuation>): ActionEval {\n  return {type: ActionType.EVAL, asts, continuations, err, exp, pos};\n}\n\ninterface ActionApply {\n  type: ActionType.APPLY;\n  continuations: ConsList<Continuation>;\n  value: MatchResult;\n}\n\nfunction applyNext(\n    continuations: ConsList<Continuation>, value: MatchResult): ActionApply {\n  return {type: ActionType.APPLY, continuations, value};\n}\n\nfunction match(\n    env: RuntimeParserConfig, start: string /* keyof env */,\n    input: string): AST|ParseError {\n  // move from initial state to halting state\n  let action = moveEval(\n      env, input,\n      evalNext(\n          env[start].exp, /*pos=*/ 0, /*asts=*/ empty(),\n          new RawError(\n              /*pos=*/ 0, /*nonterminals=*/ cons(start, empty()),\n              /*failedChars=*/ empty(),\n              /*currentNT=*/ start),\n          /*continuations=*/ empty()));\n  while (true) {\n    switch (action.type) {\n      case ActionType.EVAL:\n        action = moveEval(env, input, action);\n        break;\n      case ActionType.APPLY:\n        const {continuations, value} = action;\n        if (continuations.isEmpty()) {\n          return moveReturn(env, start, input, value);\n        }\n        action =\n            moveApply(input, value, continuations.head, continuations.tail);\n        break;\n    }\n  }\n}\n\n// Evaluates the result of the expression given in `action`.\nfunction moveEval(env: RuntimeParserConfig, input: string, action: ActionEval):\n    ActionEval|ActionApply {\n  const {exp, pos, asts, err, continuations} = action;\n  const eof = pos >= input.length;\n  switch (exp.type) {\n    case ExprType.ANY_CHAR:\n      if (eof) {\n        return applyNext(\n            continuations, reject(updateError(err, pos, new ErrAny())));\n      } else {\n        // Advance one position if the input code-point is in BMP, two positions\n        // otherwise.\n        return applyNext(\n            continuations,\n            isSingleCharCodepoint(codePointAtOrFail(input, pos)) ?\n                accept(pos + 1, cons(input[pos], asts), err) :\n                // A non single-char code-point implies !eof(pos + 1)\n                accept(pos + 2, cons(input[pos] + input[pos + 1], asts), err));\n      }\n    case ExprType.ALT: {\n      const {exprs} = exp;\n      if (exprs.isEmpty()) {\n        return applyNext(continuations, reject(err));\n      }\n      return evalNext(\n          exprs.head, pos, asts, err,\n          cons(contAlt(exprs.tail, pos, asts), continuations));\n    }\n    case ExprType.AND:\n      return evalNext(\n          exp.expr, pos, /*asts=*/ empty(), err,\n          cons(contAnd(pos, asts, err), continuations));\n    case ExprType.NOT:\n      return evalNext(\n          exp.expr, pos, /*asts=*/ empty(), err,\n          cons(contNot(pos, asts, err), continuations));\n    case ExprType.VOID:\n      return evalNext(\n          exp.expr, pos, /*asts=*/ empty(), err,\n          cons(contVoid(asts), continuations));\n    case ExprType.CHAR:\n      const c = exp.char;\n      return applyNext(\n          continuations,\n          c.length === 1 ?\n              eof || c !== input[pos] ?\n              reject(updateError(err, pos, new ErrChar(c))) :\n              accept(pos + 1, cons(input[pos], asts), err) :\n              // c.length === 2:\n              pos + 1 >= input.length || c[0] !== input[pos] ||\n                      c[1] !== input[pos + 1] ?\n              reject(updateError(err, pos, new ErrChar(c))) :\n              accept(pos + 2, cons(input[pos] + input[pos + 1], asts), err));\n    case ExprType.CHAR_CLASS:\n      const cc = exp.codepoints;\n      if (eof) {\n        return applyNext(\n            continuations, reject(updateError(err, pos, new ErrCC(cc))));\n      }\n      // JavaScript string comparison does not compare Unicode characters\n      // correctly, so we must compare codepoints. Example:\n      //   'ﬆ' > '𝌆' //=> true\n      //   'ﬆ'.codePointAt(0) > '𝌆'.codePointAt(0) //=> false\n      const inputCodePoint = codePointAtOrFail(input, pos);\n      // Loop over cc instead of recursing to avoid stack overflow on large\n      // character classes.\n      for (const charClass of cc) {\n        const isMatch = typeof charClass === 'number' ?\n            // Single character\n            charClass === inputCodePoint :\n            // Range\n            charClass[0] <= inputCodePoint && charClass[1] >= inputCodePoint;\n        if (isMatch) {\n          return applyNext(\n              continuations,\n              isSingleCharCodepoint(inputCodePoint) ?\n                  accept(pos + 1, cons(input[pos], asts), err) :\n                  accept(\n                      pos + 2, cons(input[pos] + input[pos + 1], asts), err));\n        }\n      }\n      return applyNext(\n          continuations, reject(updateError(err, pos, new ErrCC(cc))));\n    case ExprType.SEQ: {\n      // A sequence is made up of a list of expressions.\n      // We traverse the list, making sure each expression succeeds.\n      // The rest of the string returned by the expression is used\n      // as input to the next expression.\n      const {exprs} = exp;\n      if (exprs.isEmpty()) {\n        return applyNext(continuations, accept(pos, asts, err));\n      }\n      return evalNext(\n          exprs.head, pos, asts, err, cons(contSeq(exprs.tail), continuations));\n    }\n    case ExprType.PLUS:\n      return evalNext(\n          exp.expr, pos, asts, err, cons(contPlus(exp.expr), continuations));\n    case ExprType.STAR:\n      return evalNext(\n          exp.expr, pos, asts, err,\n          cons(contStar(exp.expr, pos, asts), continuations));\n    case ExprType.OPT:\n      return evalNext(\n          exp.expr, pos, asts, err, cons(contOpt(pos, asts), continuations));\n    case ExprType.NT:\n      const {name} = exp;\n      const nt = env[name];\n      return evalNext(\n          nt.exp, pos, /*asts=*/ empty(),\n          new RawError(err.pos, err.nonterminals, err.failedChars, name),\n          cons(contNT(nt.mode, name, asts, err.currentNT, pos), continuations));\n    default:\n      throw new Error(`Unsupported exp.type in exp=${\n          (exp as any).type} action=${JSON.stringify(action)}`);\n  }\n}\n\n// Handles the result of a processed continuation.\nfunction moveApply(\n    input: string, value: MatchResult, evaluated: Continuation,\n    rest: ConsList<Continuation>): ActionEval|ActionApply {\n  switch (value.type) {\n    case MatchResultType.ACCEPT:\n      return moveApplyOnAccept(input, value, evaluated, rest);\n    case MatchResultType.REJECT:\n      return moveApplyOnReject(input, value, evaluated, rest);\n  }\n}\n\n// Called after the `evaluated` continuation got accepted (matched).\nfunction moveApplyOnAccept(\n    input: string, accepted: Accepted, evaluated: Continuation,\n    rest: ConsList<Continuation>): ActionEval|ActionApply {\n  switch (evaluated.type) {\n    case ContType.SEQ: {\n      const {expressions} = evaluated;\n      if (expressions.isEmpty()) {\n        return applyNext(rest, accepted);\n      }\n      return evalNext(\n          expressions.head, accepted.pos, accepted.asts, accepted.err,\n          cons(contSeq(expressions.tail), rest));\n    }\n    case ContType.STAR:\n    case ContType.PLUS:\n      return evalNext(\n          evaluated.expression, accepted.pos, accepted.asts, accepted.err,\n          cons(\n              contStar(evaluated.expression, accepted.pos, accepted.asts),\n              rest));\n    case ContType.ALT:\n    case ContType.OPT:\n      return applyNext(rest, accepted);\n    case ContType.AND:\n      return applyNext(\n          rest, accept(evaluated.pos, evaluated.asts, evaluated.err));\n    case ContType.VOID:\n      return applyNext(\n          rest, accept(accepted.pos, evaluated.asts, accepted.err));\n    case ContType.NOT:\n      return applyNext(rest, reject(evaluated.err));\n    case ContType.NT:\n      const {mode, name, asts, nt} = evaluated;\n      const valAsts = accepted.asts;\n      const newErr = new RawError(\n          accepted.err.pos, accepted.err.nonterminals, accepted.err.failedChars,\n          nt);\n      switch (mode) {\n        case NonTerminalMode.NORMAL:\n          return applyNext(\n              rest,\n              accept(\n                  accepted.pos,\n                  cons(\n                      new AST(\n                          name, valAsts.toArray().reverse(), evaluated.startPos,\n                          accepted.pos),\n                      asts),\n                  newErr));\n        case NonTerminalMode.PRUNING:\n          if (valAsts.isEmpty()) {\n            return applyNext(rest, accept(accepted.pos, asts, newErr));\n          } else if (valAsts.tail.isEmpty()) {\n            return applyNext(\n                rest, accept(accepted.pos, cons(valAsts.head, asts), newErr));\n          } else {\n            return applyNext(\n                rest,\n                accept(\n                    accepted.pos,\n                    cons(\n                        new AST(\n                            name, valAsts.toArray().reverse(),\n                            evaluated.startPos, accepted.pos),\n                        asts),\n                    newErr));\n          }\n        case NonTerminalMode.VOIDING:\n          return applyNext(rest, accept(accepted.pos, asts, newErr));\n        default:\n          // Without this check, the TypeScript compiler doesn't\n          // realize that the outer case is also exhaustive.\n          throw checkExhaustive(mode, 'Invalid mode');\n      }\n  }\n}\n\n// Called after the `evaluated` continuation got rejected (did not match).\nfunction moveApplyOnReject(\n    input: string, rejected: Rejected, evaluated: Continuation,\n    continuations: ConsList<Continuation>): ActionEval|ActionApply {\n  switch (evaluated.type) {\n    case ContType.ALT: {\n      const {expressions} = evaluated;\n      if (expressions.isEmpty()) {\n        return applyNext(continuations, rejected);\n      }\n      return evalNext(\n          expressions.head, evaluated.pos, evaluated.asts, rejected.err,\n          cons(\n              contAlt(expressions.tail, evaluated.pos, evaluated.asts),\n              continuations));\n    }\n    case ContType.SEQ:\n    case ContType.VOID:\n    case ContType.PLUS:\n      return applyNext(continuations, rejected);\n    case ContType.AND:\n      return applyNext(continuations, reject(evaluated.err));\n    case ContType.NOT:\n    case ContType.STAR:\n    case ContType.OPT:\n      return applyNext(\n          continuations, accept(evaluated.pos, evaluated.asts, rejected.err));\n    case ContType.NT:\n      const err = rejected.err;\n      return applyNext(\n          continuations,\n          reject(new RawError(\n              err.pos, err.nonterminals, err.failedChars, evaluated.nt)));\n    default:\n      throw checkExhaustive(evaluated, 'Invalid continuation');\n  }\n}\n\n// Called after the final continuation was processed.\nfunction moveReturn(\n    env: RuntimeParserConfig, start: string /* keyof env */, input: string,\n    value: MatchResult): AST|ParseError {\n  switch (value.type) {\n    case MatchResultType.ACCEPT:\n      const asts = value.asts;\n      if (value.pos >= input.length) {\n        const mode = env[start].mode;\n        switch (mode) {\n          case NonTerminalMode.NORMAL:\n            return new AST(start, asts.toArray().reverse(), 0, value.pos);\n          case NonTerminalMode.PRUNING:\n            if (asts.isEmpty()) {\n              return EmptyAST(0, value.pos);\n            } else if (asts.tail.isEmpty()) {\n              const ast = asts.head;\n              if (typeof ast === 'string') {\n                throw new Error(`Expected an AST, got a string ${\n                    JSON.stringify(ast)}, in ${value}`);\n              }\n              return ast;\n            } else {\n              return new AST(start, asts.toArray().reverse(), 0, value.pos);\n            }\n          case NonTerminalMode.VOIDING:\n            return EmptyAST(0, value.pos);\n          default:\n            throw checkExhaustive(mode, 'Invalid mode');\n        }\n      } else if (value.err && value.pos === value.err.pos) {\n        return new RawError(\n                   value.pos, value.err.nonterminals, value.err.failedChars, '')\n            .toParseError(input);\n      } else {\n        return new RawError(value.pos, empty(), empty(), '')\n            .toParseError(input);\n      }\n    case MatchResultType.REJECT:\n      return value.err.toParseError(input);\n    default:\n      throw checkExhaustive(value, 'Invalid MatchResultType');\n  }\n}\n\nfunction getLineCol(pos: number, input: string): [number, number] {\n  let lineNumber = 1;\n  let lineStartPos = 0;\n  let newlinePos = -1;\n  // tslint:disable-next-line:no-conditional-assignment\n  while ((newlinePos = input.indexOf('\\n', lineStartPos)) !== -1 &&\n         newlinePos < pos) {\n    ++lineNumber;\n    lineStartPos = newlinePos + 1;\n  }\n  return [lineNumber, pos - lineStartPos + 1];\n}\n\n// Whether the given Unicode code-point can be represented\n// by a single JavaScript String (UTF-16) character.\nfunction isSingleCharCodepoint(codePoint: number) {\n  return codePoint <= 0xFFFF;\n}\n\nfunction codePointAtOrFail(input: string, pos: number): number {\n  const codePoint = input.codePointAt(pos);\n  if (typeof codePoint === 'undefined') {\n    throw new Error(\n        `Undefined input codepoint at ${pos} in ${JSON.stringify(input)}`);\n  }\n  return codePoint;\n}\n\n// Performs a compile-time check that the current codepath is unreachable, and\n// throws an exception at run-time should the type system be compromised.\n// Particularly useful as the 'default' case in a switch.\nfunction checkExhaustive(value: never, message: string): never {\n  throw new Error(`${message}: ${JSON.stringify(value)}`);\n}\n"],"sourceRoot":""}